{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "import copy\n",
    "import numpy as np\n",
    "import pandas as pd\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Parâmetros Globais\n",
    "total_nodes = 4  # Nós: 0, 1, 2, 3\n",
    "total_functions = 8  # Funções: 0 a 7\n",
    "\n",
    "# Topologia Física \n",
    "physical_topology = np.ones((total_nodes, total_nodes)) - np.eye(total_nodes)\n",
    "\n",
    "# Coordenadas dos Nós\n",
    "position_nodes = {\n",
    "    0: [0.1, 0.1],\n",
    "    1: [0.1, 0.9],\n",
    "    2: [0.9, 0.1],\n",
    "    3: [0.9, 0.9],\n",
    "}\n",
    "\n",
    "# Definição das Funções (VNFs)\n",
    "functions = list(range(total_functions))  # Funções de 0 a 7\n",
    "\n",
    "# Serviços e suas Cadeias de Funções (SFCs)\n",
    "# (0) Origem (1) NAT (2) FW (3) TM (4) WOC (5) VOC (6) IDS (7) Destino\n",
    "\n",
    "# Definição dos serviços\n",
    "# Funções necessárias para cada serviço (1 = necessário, 0 = não necessário)\n",
    "wbf = [1, 1, 1, 1, 1, 0, 1, 1]\n",
    "vipf = [1, 1, 1, 1, 0, 0, 0, 1]\n",
    "vsf = [1, 1, 1, 1, 0, 1, 1, 1]\n",
    "ogf = [1, 1, 1, 0, 1, 1, 1, 1]\n",
    "\n",
    "# Matrizes de adjacência das SFCs\n",
    "# Serviço 'wb'\n",
    "wb_sfc = [\n",
    "    [0, 1, 0, 0, 0, 0, 0, 0],  # 0\n",
    "    [0, 0, 1, 0, 0, 0, 0, 0],  # 1\n",
    "    [0, 0, 0, 1, 0, 0, 0, 0],  # 2\n",
    "    [0, 0, 0, 0, 1, 0, 0, 0],  # 3\n",
    "    [0, 0, 0, 0, 0, 0, 1, 0],  # 4\n",
    "    [0, 0, 0, 0, 0, 0, 0, 0],  # 5\n",
    "    [0, 0, 0, 0, 0, 0, 0, 1],  # 6\n",
    "    [0, 0, 0, 0, 0, 0, 0, 0],  # 7\n",
    "]\n",
    "\n",
    "# Serviço 'vip'\n",
    "vip_sfc = [\n",
    "    [0, 1, 0, 0, 0, 0, 0, 0],  # 0\n",
    "    [0, 0, 1, 0, 0, 0, 0, 1],  # 1\n",
    "    [0, 1, 0, 1, 0, 0, 0, 0],  # 2\n",
    "    [0, 0, 1, 0, 0, 0, 0, 0],  # 3\n",
    "    [0, 0, 0, 0, 0, 0, 0, 0],  # 4\n",
    "    [0, 0, 0, 0, 0, 0, 0, 0],  # 5\n",
    "    [0, 0, 0, 0, 0, 0, 0, 0],  # 6\n",
    "    [0, 0, 0, 0, 0, 0, 0, 0],  # 7\n",
    "]\n",
    "\n",
    "# Serviço 'vs'\n",
    "vs_sfc = [\n",
    "    [0, 1, 0, 0, 0, 0, 0, 0],  # 0\n",
    "    [0, 0, 1, 0, 0, 0, 0, 0],  # 1\n",
    "    [0, 0, 0, 1, 0, 0, 0, 0],  # 2\n",
    "    [0, 0, 0, 0, 0, 1, 0, 0],  # 3\n",
    "    [0, 0, 0, 0, 0, 0, 0, 0],  # 4\n",
    "    [0, 0, 0, 0, 0, 0, 1, 0],  # 5\n",
    "    [0, 0, 0, 0, 0, 0, 0, 1],  # 6\n",
    "    [0, 0, 0, 0, 0, 0, 0, 0],  # 7\n",
    "]\n",
    "\n",
    "# Serviço 'og'\n",
    "og_sfc = [\n",
    "    [0, 1, 0, 0, 0, 0, 0, 0],  # 0\n",
    "    [0, 0, 1, 0, 0, 0, 0, 0],  # 1\n",
    "    [0, 0, 0, 0, 0, 1, 0, 0],  # 2\n",
    "    [0, 0, 0, 0, 0, 0, 0, 0],  # 3\n",
    "    [0, 0, 0, 0, 0, 0, 1, 0],  # 4\n",
    "    [0, 0, 0, 0, 1, 0, 0, 0],  # 5\n",
    "    [0, 0, 0, 0, 0, 0, 0, 1],  # 6\n",
    "    [0, 0, 0, 0, 0, 0, 0, 0],  # 7\n",
    "]\n",
    "\n",
    "# Serviços\n",
    "services = {\n",
    "    'wb': {\n",
    "        'functions': wbf,\n",
    "        'sfc': wb_sfc,\n",
    "    },\n",
    "    'vip': {\n",
    "        'functions': vipf,\n",
    "        'sfc': vip_sfc,\n",
    "    },\n",
    "    'vs': {\n",
    "        'functions': vsf,\n",
    "        'sfc': vs_sfc,\n",
    "    },\n",
    "    'og': {\n",
    "        'functions': ogf,\n",
    "        'sfc': og_sfc,\n",
    "    },\n",
    "}\n",
    "\n",
    "# Demandas\n",
    "demands = [\n",
    "    {'id': 0, 'source': 0, 'destiny': 1, 'service': services['wb']},\n",
    "    {'id': 1, 'source': 1, 'destiny': 2, 'service': services['vs']},\n",
    "    {'id': 2, 'source': 2, 'destiny': 3, 'service': services['og']},\n",
    "    {'id': 3, 'source': 3, 'destiny': 0, 'service': services['vip']},\n",
    "]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Função para inicializar a população\n",
    "def inicializar_populacao(tamanho_populacao, total_functions, total_nodes):\n",
    "    populacao = []\n",
    "    for _ in range(tamanho_populacao):\n",
    "        allocation = [None] * total_functions\n",
    "        for k in range(total_functions):\n",
    "            if k == 0 or k == 7:\n",
    "                allocation[k] = -1  # Marcador para ser definido durante a avaliação\n",
    "            else:\n",
    "                allocation[k] = random.randint(0, total_nodes - 1)\n",
    "        individuo = {'allocation': allocation}\n",
    "        populacao.append(individuo)\n",
    "    return populacao\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Função de aptidão para contar os hops\n",
    "def calcular_aptidao(individuo, demands, total_nodes, physical_topology):\n",
    "    custo_alocacao = 0\n",
    "    custo_fluxo = 0\n",
    "    penalidades = 0\n",
    "\n",
    "    allocation = individuo['allocation']\n",
    "\n",
    "    # Conjunto de funções alocadas (excluindo origem e destino)\n",
    "    funcoes_alocadas = set()\n",
    "\n",
    "    for demanda in demands:\n",
    "        source = demanda['source']\n",
    "        destiny = demanda['destiny']\n",
    "        service_functions = demanda['service']['functions']\n",
    "        sfc = demanda['service']['sfc']\n",
    "        sfc_functions = [k for k, val in enumerate(service_functions) if val > 0]\n",
    "\n",
    "        # Fazer uma cópia local da alocação para esta demanda\n",
    "        allocation_demanda = allocation.copy()\n",
    "        allocation_demanda[0] = source  # Função de origem (0) alocada no nó de origem\n",
    "        allocation_demanda[7] = destiny  # Função de destino (7) alocada no nó de destino\n",
    "\n",
    "        nos_funcoes = [allocation_demanda[k] for k in sfc_functions]\n",
    "\n",
    "        # Verificar se alguma função necessária não está alocada\n",
    "        if None in nos_funcoes or -1 in nos_funcoes:\n",
    "            penalidades += 100  # Penalidade alta por funções não alocadas\n",
    "            continue\n",
    "\n",
    "        # Adicionar funções alocadas (excluindo origem e destino)\n",
    "        for k in sfc_functions:\n",
    "            if k != 0 and k != 7:\n",
    "                funcoes_alocadas.add((k, allocation_demanda[k]))\n",
    "\n",
    "        # Construir o caminho completo da demanda\n",
    "        caminho_demanda = []\n",
    "\n",
    "        # Incluir a origem\n",
    "        caminho_demanda.append(source)\n",
    "\n",
    "        # Incluir os nós onde as funções estão alocadas, na ordem da SFC\n",
    "        for k in sfc_functions:\n",
    "            if k != 0 and k != 7:\n",
    "                caminho_demanda.append(allocation_demanda[k])\n",
    "\n",
    "        # Incluir o destino\n",
    "        caminho_demanda.append(destiny)\n",
    "\n",
    "        # Calcular hops da demanda\n",
    "        hops_demanda = 0\n",
    "        for i in range(len(caminho_demanda) - 1):\n",
    "            no_atual = caminho_demanda[i]\n",
    "            proximo_no = caminho_demanda[i + 1]\n",
    "\n",
    "            if no_atual != proximo_no:\n",
    "                # Verificar se existe link direto\n",
    "                if physical_topology[no_atual][proximo_no] == 0:\n",
    "                    penalidades += 100  # Penalidade se não houver link direto\n",
    "                    print(f'Penalidade aplicada na demanda {demanda[\"id\"]} entre os nós {no_atual} e {proximo_no}')\n",
    "                    continue\n",
    "\n",
    "                hops_demanda += 1\n",
    "\n",
    "        custo_fluxo += hops_demanda\n",
    "\n",
    "    # Calcular custos\n",
    "    custo_alocacao = len(funcoes_alocadas)\n",
    "\n",
    "    # Calcular função de aptidão\n",
    "    aptidao = custo_alocacao + custo_fluxo + penalidades\n",
    "    individuo['fitness'] = aptidao\n",
    "    individuo['funcoes_alocadas'] = funcoes_alocadas\n",
    "    return aptidao\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Operadores Genéticos\n",
    "def selecao_torneio(populacao, k=3):\n",
    "    selecionados = []\n",
    "    for _ in range(len(populacao)):\n",
    "        competidores = random.sample(populacao, k)\n",
    "        competidores.sort(key=lambda ind: ind['fitness'])\n",
    "        selecionados.append(competidores[0])\n",
    "    return selecionados\n",
    "\n",
    "def cruzamento(pai1, pai2):\n",
    "    ponto_corte = random.randint(1, len(pai1['allocation']) - 2)\n",
    "    filho1_allocation = pai1['allocation'][:ponto_corte] + pai2['allocation'][ponto_corte:]\n",
    "    filho2_allocation = pai2['allocation'][:ponto_corte] + pai1['allocation'][ponto_corte:]\n",
    "    filho1 = {'allocation': filho1_allocation}\n",
    "    filho2 = {'allocation': filho2_allocation}\n",
    "    return filho1, filho2\n",
    "\n",
    "def mutacao(individuo, taxa_mutacao, total_nodes):\n",
    "    allocation = individuo['allocation']\n",
    "    for k in range(1, len(allocation) - 1):  # Não alterar funções 0 e 7\n",
    "        if random.random() < taxa_mutacao:\n",
    "            allocation[k] = random.randint(0, total_nodes - 1)\n",
    "    individuo['allocation'] = allocation\n",
    "    return individuo\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Geração 0: Melhor Aptidão = 16\n",
      "Geração 1: Melhor Aptidão = 14\n",
      "Geração 2: Melhor Aptidão = 14\n",
      "Geração 3: Melhor Aptidão = 14\n",
      "Geração 4: Melhor Aptidão = 12\n",
      "Geração 5: Melhor Aptidão = 14\n",
      "Geração 6: Melhor Aptidão = 12\n",
      "Geração 7: Melhor Aptidão = 12\n",
      "Geração 8: Melhor Aptidão = 12\n",
      "Geração 9: Melhor Aptidão = 12\n",
      "Geração 10: Melhor Aptidão = 12\n",
      "Geração 11: Melhor Aptidão = 12\n",
      "Geração 12: Melhor Aptidão = 12\n",
      "Geração 13: Melhor Aptidão = 12\n",
      "Geração 14: Melhor Aptidão = 12\n",
      "Geração 15: Melhor Aptidão = 12\n",
      "Geração 16: Melhor Aptidão = 12\n",
      "Geração 17: Melhor Aptidão = 12\n",
      "Geração 18: Melhor Aptidão = 12\n",
      "Geração 19: Melhor Aptidão = 12\n",
      "Geração 20: Melhor Aptidão = 12\n",
      "Geração 21: Melhor Aptidão = 12\n",
      "Geração 22: Melhor Aptidão = 12\n",
      "Geração 23: Melhor Aptidão = 12\n",
      "Geração 24: Melhor Aptidão = 12\n",
      "Geração 25: Melhor Aptidão = 12\n",
      "Geração 26: Melhor Aptidão = 12\n",
      "Geração 27: Melhor Aptidão = 12\n",
      "Geração 28: Melhor Aptidão = 12\n",
      "Geração 29: Melhor Aptidão = 12\n",
      "Geração 30: Melhor Aptidão = 12\n",
      "Geração 31: Melhor Aptidão = 12\n",
      "Geração 32: Melhor Aptidão = 12\n",
      "Geração 33: Melhor Aptidão = 12\n",
      "Geração 34: Melhor Aptidão = 12\n",
      "Geração 35: Melhor Aptidão = 12\n",
      "Geração 36: Melhor Aptidão = 12\n",
      "Geração 37: Melhor Aptidão = 12\n",
      "Geração 38: Melhor Aptidão = 12\n",
      "Geração 39: Melhor Aptidão = 12\n",
      "Geração 40: Melhor Aptidão = 12\n",
      "Geração 41: Melhor Aptidão = 12\n",
      "Geração 42: Melhor Aptidão = 12\n",
      "Geração 43: Melhor Aptidão = 12\n",
      "Geração 44: Melhor Aptidão = 12\n",
      "Geração 45: Melhor Aptidão = 12\n",
      "Geração 46: Melhor Aptidão = 12\n",
      "Geração 47: Melhor Aptidão = 12\n",
      "Geração 48: Melhor Aptidão = 12\n",
      "Geração 49: Melhor Aptidão = 12\n",
      "Geração 50: Melhor Aptidão = 12\n",
      "Geração 51: Melhor Aptidão = 12\n",
      "Geração 52: Melhor Aptidão = 12\n",
      "Geração 53: Melhor Aptidão = 12\n",
      "Geração 54: Melhor Aptidão = 12\n",
      "Geração 55: Melhor Aptidão = 12\n",
      "Geração 56: Melhor Aptidão = 12\n",
      "Geração 57: Melhor Aptidão = 12\n",
      "Geração 58: Melhor Aptidão = 12\n",
      "Geração 59: Melhor Aptidão = 12\n",
      "Geração 60: Melhor Aptidão = 12\n",
      "Geração 61: Melhor Aptidão = 12\n",
      "Geração 62: Melhor Aptidão = 12\n",
      "Geração 63: Melhor Aptidão = 12\n",
      "Geração 64: Melhor Aptidão = 12\n",
      "Geração 65: Melhor Aptidão = 12\n",
      "Geração 66: Melhor Aptidão = 12\n",
      "Geração 67: Melhor Aptidão = 12\n",
      "Geração 68: Melhor Aptidão = 12\n",
      "Geração 69: Melhor Aptidão = 12\n",
      "Geração 70: Melhor Aptidão = 12\n",
      "Geração 71: Melhor Aptidão = 12\n",
      "Geração 72: Melhor Aptidão = 12\n",
      "Geração 73: Melhor Aptidão = 12\n",
      "Geração 74: Melhor Aptidão = 12\n",
      "Geração 75: Melhor Aptidão = 12\n",
      "Geração 76: Melhor Aptidão = 12\n",
      "Geração 77: Melhor Aptidão = 12\n",
      "Geração 78: Melhor Aptidão = 12\n",
      "Geração 79: Melhor Aptidão = 12\n",
      "Geração 80: Melhor Aptidão = 12\n",
      "Geração 81: Melhor Aptidão = 12\n",
      "Geração 82: Melhor Aptidão = 12\n",
      "Geração 83: Melhor Aptidão = 12\n",
      "Geração 84: Melhor Aptidão = 12\n",
      "Geração 85: Melhor Aptidão = 12\n",
      "Geração 86: Melhor Aptidão = 12\n",
      "Geração 87: Melhor Aptidão = 12\n",
      "Geração 88: Melhor Aptidão = 12\n",
      "Geração 89: Melhor Aptidão = 12\n",
      "Geração 90: Melhor Aptidão = 12\n",
      "Geração 91: Melhor Aptidão = 12\n",
      "Geração 92: Melhor Aptidão = 12\n",
      "Geração 93: Melhor Aptidão = 12\n",
      "Geração 94: Melhor Aptidão = 12\n",
      "Geração 95: Melhor Aptidão = 12\n",
      "Geração 96: Melhor Aptidão = 12\n",
      "Geração 97: Melhor Aptidão = 12\n",
      "Geração 98: Melhor Aptidão = 12\n",
      "Geração 99: Melhor Aptidão = 12\n"
     ]
    }
   ],
   "source": [
    "# Parâmetros do AG\n",
    "tamanho_populacao = 50\n",
    "max_geracoes = 100\n",
    "taxa_cruzamento = 0.8\n",
    "taxa_mutacao = 0.05\n",
    "\n",
    "# Inicializar população\n",
    "populacao = inicializar_populacao(tamanho_populacao, total_functions, total_nodes)\n",
    "\n",
    "# Avaliar aptidão inicial\n",
    "for individuo in populacao:\n",
    "    calcular_aptidao(individuo, demands, total_nodes, physical_topology)\n",
    "\n",
    "# Evolução das gerações\n",
    "for geracao in range(max_geracoes):\n",
    "    # Seleção\n",
    "    pais = selecao_torneio(populacao)\n",
    "\n",
    "    # Cruzamento\n",
    "    filhos = []\n",
    "    for i in range(0, len(pais), 2):\n",
    "        pai1 = pais[i]\n",
    "        pai2 = pais[i+1] if i+1 < len(pais) else pais[0]\n",
    "        if random.random() < taxa_cruzamento:\n",
    "            filho1, filho2 = cruzamento(pai1, pai2)\n",
    "        else:\n",
    "            filho1, filho2 = copy.deepcopy(pai1), copy.deepcopy(pai2)\n",
    "        filhos.extend([filho1, filho2])\n",
    "\n",
    "    # Mutação\n",
    "    nova_populacao = []\n",
    "    for individuo in filhos:\n",
    "        individuo = mutacao(individuo, taxa_mutacao, total_nodes)\n",
    "        nova_populacao.append(individuo)\n",
    "\n",
    "    # Avaliar aptidão\n",
    "    for individuo in nova_populacao:\n",
    "        calcular_aptidao(individuo, demands, total_nodes, physical_topology)\n",
    "\n",
    "    # Substituir população\n",
    "    populacao = nova_populacao\n",
    "\n",
    "    # Imprimir melhor aptidão da geração\n",
    "    melhores_aptidoes = [ind['fitness'] for ind in populacao]\n",
    "    melhor_aptidao = min(melhores_aptidoes)\n",
    "    print(f'Geração {geracao}: Melhor Aptidão = {melhor_aptidao}')\n",
    "\n",
    "# Selecionar melhor indivíduo\n",
    "populacao.sort(key=lambda ind: ind['fitness'])\n",
    "melhor_individuo = populacao[0]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Melhor Solução Encontrada:\n",
      "Alocação das Funções: [-1, 3, 3, 3, 3, 3, 3, -1]\n",
      "Funções Alocadas (excluindo origem e destino): {(4, 3), (2, 3), (3, 3), (5, 3), (6, 3), (1, 3)}\n",
      "Custo de Alocação: 6\n",
      "Aptidão (Função Objetivo): 12\n"
     ]
    }
   ],
   "source": [
    "# Visualização dos Resultados\n",
    "print('\\nMelhor Solução Encontrada:')\n",
    "print('Alocação das Funções:', melhor_individuo['allocation'])\n",
    "print('Funções Alocadas (excluindo origem e destino):', melhor_individuo['funcoes_alocadas'])\n",
    "print('Custo de Alocação:', len(melhor_individuo['funcoes_alocadas']))\n",
    "\n",
    "#Custo de fluxo\n",
    "print('Aptidão (Função Objetivo):', melhor_individuo['fitness'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Funções x Servidores - Onde a função k está sendo alocada? (Variável : X)\n",
      "============================================================\n",
      "       Source  NAT   FW   TM  WOC  VOC  IDS Destiny\n",
      "Node 0    1.0    .    .    .    .    .    .     1.0\n",
      "Node 1    1.0    .    .    .    .    .    .     1.0\n",
      "Node 2    1.0    .    .    .    .    .    .     1.0\n",
      "Node 3    1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0\n",
      "\n",
      "Onde a demanda d está usando a função k?  (Variável : U)\n",
      "============================================================\n",
      "                   Source  NAT   FW   TM  WOC  VOC  IDS Destiny\n",
      "Demanda   Servidor                                             \n",
      "Demanda 0 Node 0      1.0    .    .    .    .    .    .       .\n",
      "          Node 1        .    .    .    .    .    .    .     1.0\n",
      "          Node 2        .    .    .    .    .    .    .       .\n",
      "          Node 3        .  1.0  1.0  1.0  1.0    .  1.0       .\n",
      "Demanda 1 Node 0        .    .    .    .    .    .    .       .\n",
      "          Node 1      1.0    .    .    .    .    .    .       .\n",
      "          Node 2        .    .    .    .    .    .    .     1.0\n",
      "          Node 3        .  1.0  1.0  1.0    .  1.0  1.0       .\n",
      "Demanda 2 Node 0        .    .    .    .    .    .    .       .\n",
      "          Node 1        .    .    .    .    .    .    .       .\n",
      "          Node 2      1.0    .    .    .    .    .    .       .\n",
      "          Node 3        .  1.0  1.0    .  1.0  1.0  1.0     1.0\n",
      "Demanda 3 Node 0        .    .    .    .    .    .    .     1.0\n",
      "          Node 1        .    .    .    .    .    .    .       .\n",
      "          Node 2        .    .    .    .    .    .    .       .\n",
      "          Node 3      1.0  1.0  1.0  1.0    .    .    .       .\n",
      "\n",
      "Qual o fluxo da demanda d?  (Variável : W)\n",
      "============================================================\n",
      "                   Node 0 Node 1 Node 2 Node 3\n",
      "Demanda   Servidor                            \n",
      "Demanda 0 Node 0        O      .      .    1.0\n",
      "          Node 1        .      D      .      .\n",
      "          Node 2        .      .      .      .\n",
      "          Node 3        .    1.0      .      .\n",
      "Demanda 1 Node 0        .      .      .      .\n",
      "          Node 1        .      O      .    1.0\n",
      "          Node 2        .      .      D      .\n",
      "          Node 3        .      .    1.0      .\n",
      "Demanda 2 Node 0        .      .      .      .\n",
      "          Node 1        .      .      .      .\n",
      "          Node 2        .      .      O    1.0\n",
      "          Node 3        .      .      .      D\n",
      "Demanda 3 Node 0        D      .      .      .\n",
      "          Node 1        .      .      .      .\n",
      "          Node 2        .      .      .      .\n",
      "          Node 3      1.0      .      .      O\n"
     ]
    }
   ],
   "source": [
    "# -------------------------------------\n",
    "#       Código de Visualização\n",
    "# -------------------------------------\n",
    "\n",
    "# Criação de DataFrames para visualização\n",
    "nodes_labels = [f'Node {i}' for i in range(total_nodes)]\n",
    "funcoes_labels = ['Source', 'NAT', 'FW', 'TM', 'WOC', 'VOC', 'IDS', 'Destiny']\n",
    "demands_labels = [f'Demanda {d[\"id\"]}' for d in demands]\n",
    "\n",
    "# DataFrame de Funções x Servidores (Alocação das Funções)\n",
    "df_placement = pd.DataFrame('.', index=nodes_labels, columns=funcoes_labels)\n",
    "\n",
    "# Preencher o DataFrame de Alocação\n",
    "allocation = melhor_individuo['allocation']\n",
    "for k, node in enumerate(allocation):\n",
    "    if node is not None and node != -1:\n",
    "        df_placement.loc[f'Node {node}', funcoes_labels[k]] = '1.0'\n",
    "\n",
    "# As funções de origem e destino são alocadas nos nós de origem e destino de cada demanda\n",
    "for demanda in demands:\n",
    "    df_placement.loc[f'Node {demanda[\"source\"]}', 'Source'] = '1.0'\n",
    "    df_placement.loc[f'Node {demanda[\"destiny\"]}', 'Destiny'] = '1.0'\n",
    "\n",
    "print('\\nFunções x Servidores - Onde a função k está sendo alocada? (Variável : X)')\n",
    "print('=' * 60)\n",
    "print(df_placement)\n",
    "\n",
    "# DataFrame de Demanda-Nodes X Funções (Uso das Funções pelas Demandas)\n",
    "index = pd.MultiIndex.from_product([demands_labels, nodes_labels], names=['Demanda', 'Servidor'])\n",
    "df_used = pd.DataFrame('.', index=index, columns=funcoes_labels)\n",
    "\n",
    "# Preencher o DataFrame de Uso das Funções\n",
    "for demanda in demands:\n",
    "    d_label = f'Demanda {demanda[\"id\"]}'\n",
    "    service_functions = demanda['service']['functions']\n",
    "    sfc_functions = [k for k, val in enumerate(service_functions) if val > 0]\n",
    "\n",
    "    # Alocação das funções para esta demanda\n",
    "    allocation_demanda = melhor_individuo['allocation'].copy()\n",
    "    allocation_demanda[0] = demanda['source']\n",
    "    allocation_demanda[7] = demanda['destiny']\n",
    "\n",
    "    for k in sfc_functions:\n",
    "        node = allocation_demanda[k]\n",
    "        n_label = f'Node {node}'\n",
    "        df_used.loc[(d_label, n_label), funcoes_labels[k]] = '1.0'\n",
    "\n",
    "print('\\nOnde a demanda d está usando a função k?  (Variável : U)')\n",
    "print('=' * 60)\n",
    "print(df_used)\n",
    "\n",
    "# DataFrame de Demanda-Nodes X Nodes (Fluxo das Demandas)\n",
    "df_percurso = pd.DataFrame('.', index=index, columns=nodes_labels)\n",
    "\n",
    "# Preencher o DataFrame de Fluxo das Demandas\n",
    "for demanda in demands:\n",
    "    d_label = f'Demanda {demanda[\"id\"]}'\n",
    "    service_functions = demanda['service']['functions']\n",
    "    sfc_functions = [k for k, val in enumerate(service_functions) if val > 0]\n",
    "\n",
    "    # Alocação das funções para esta demanda\n",
    "    allocation_demanda = melhor_individuo['allocation'].copy()\n",
    "    allocation_demanda[0] = demanda['source']\n",
    "    allocation_demanda[7] = demanda['destiny']\n",
    "\n",
    "    # Construir o caminho completo da demanda\n",
    "    caminho_demanda = []\n",
    "\n",
    "    # Incluir a origem\n",
    "    caminho_demanda.append(demanda['source'])\n",
    "\n",
    "    # Incluir os nós onde as funções estão alocadas, na ordem da SFC\n",
    "    for k in sfc_functions:\n",
    "        if k != 0 and k != 7:\n",
    "            caminho_demanda.append(allocation_demanda[k])\n",
    "\n",
    "    # Incluir o destino\n",
    "    caminho_demanda.append(demanda['destiny'])\n",
    "\n",
    "    # Marcar origem e destino\n",
    "    n_label = f'Node {demanda[\"source\"]}'\n",
    "    df_percurso.loc[(d_label, n_label), n_label] = 'O'\n",
    "    n_label = f'Node {demanda[\"destiny\"]}'\n",
    "    df_percurso.loc[(d_label, n_label), n_label] = 'D'\n",
    "\n",
    "    # Marcar o percurso\n",
    "    for i in range(len(caminho_demanda) - 1):\n",
    "        no_atual = caminho_demanda[i]\n",
    "        proximo_no = caminho_demanda[i + 1]\n",
    "        n_label = f'Node {no_atual}'\n",
    "        p_label = f'Node {proximo_no}'\n",
    "\n",
    "        if no_atual != proximo_no:\n",
    "            df_percurso.loc[(d_label, n_label), p_label] = '1.0'\n",
    "\n",
    "print('\\nQual o fluxo da demanda d?  (Variável : W)')\n",
    "print('=' * 60)\n",
    "print(df_percurso)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "math",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.17"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
